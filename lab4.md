# Отчет по лабораторной работе №4

## Цель

Знакомство студентов с алгоритмами кэширования. В рамках данной работы необходимо разработать кэширующий SQL-proxy - программу, которая принимала бы запросы к БД, отправляла эти запросы в БД, сохраняла бы результаты в хранилище. Если приходит повторный запрос на чтение - выдавала запросы из хранилища, если приходит запрос на изменение - сбрасывала бы значения всех запросов, результаты которых станут неактуальными после внесенных изменений.

## Программа работы

1. Общее описание:
    * для данной работы необходимо выбрать часть таблиц БД (3+), для которой можно придумать/использовать осмысленные SQL-запросы, необходимые для выполнения пользовательских функций
    * в рамках работы необходимо реализовать две программы: кэширующий прокси и программа для выполнения запросов и измерения результатов

2. Выбор понравившегося способа кэширования:
    * в памяти программы
    * с использованием внешних хранилищ
    * во внешней памяти

3. Реализация выбранного способа:
    * преобразование входных запросов
    * выбор ключа для хранения результатов
    * реализация алгоритма поиска сохраненных результатов, которые надо сбросить после внесения изменений в БД

4. Снятие показательных характеристик:

    * в программе для формирования потока запросов к БД на чтение/изменение/удаление должна быть возможность настройки соотношения запросов, количества запросов разных типов в потоке и измерения временных характеристик: среднее/минимальное/максимальное время выполнения запроса по типу, необходимо иметь возможность проанализировать эффективность кэширования в различных сценариев: преимущественно чтение, преимущественно изменение, преимущественно удаление
    * измерения можно производить путем простого сравнения отметок текущего времени до и после выполнения запросов

5. Анализ полученных результатов и сравнение реализаций с кэшем и без между собой.

6. Демонстрация результатов преподавателю.

### Ход работы

1. Предварительные заметки
    * Я выбрал 3 таблицы - Stations, Routes, RouteSections.
    * Важно! Я починил генератор данных (иногда время отправления и прибытия совпадали, на что есть ограничение в схеме, поэтому бросалось исключение).
    * БД заполняется с параметрами -s (stations) равным 500 и -r (routes) равным 2000 (количество записей в route_sections пропорционально количеству записей routes, в среднем длина маршрута 5 участков тогда всего там около 10000 записей).
    * Для взаимодействия с ДБ я выбрал <https://crates.io/crates/postgres>
    * Прокси и клиент общаются через <https://doc.rust-lang.org/std/sync/mpsc/> из разных потоков

2. Выбор способа кэширования:
    * Очевидно, что самый простой (и быстрый) способ реализовать кэш - в памяти программы.

3. Реализация выбранного способа:
    * В качестве ключей я выбрал сами запросы (без предварительной обработки). Но мне пришлось отдельно указывать, какие таблицы используется в запросе (или будут изменены) - [код с запросами](lab4/cacher/src/requests/mod.rs).
    * Реализация самого кэша лежит в [файле](lab4/cacher/src/handler/cache.rs). К нему написаны 2 теста - их можно запустить командой ```cargo test```. Кэш состоит из двух частей - собственно [LRU кэш](https://crates.io/crates/lru) и hashmap, в котором хранятся пары "имя таблицы"-"список запросов", он используется, чтобы удалять те элементы кэша, которые не отражают актуальную информацию после изменения. Когда мы объявляем таблицу недействительной мы удаляем все запросы в списке из кэша и сбрасываем список.

4. Снятие показательных характеристик:
    * Я решил объединить Delete и Update запросы, так как они похожи в том смысле, что сбрасывают кэш (если число измененных записей не равно нулю - это учитывается в моей реализации).
    * Запросы выбираются случайным образом (Select и Delete/Update выбираются отдельно, вероятность выбора между Select и Delete/Update можно задать параметром).
    * Измерения производятся путем простого сравнения отметок текущего времени до и после выполнения запросов.

5. Анализ полученных результатов и сравнение реализаций с кэшем и без между собой:
    * По умолчанию выполняется 10000 запросов (всего), размер кэша - 8 записей, вероятность выполнения Select запроса вместо Delete/Update равна 10%.

